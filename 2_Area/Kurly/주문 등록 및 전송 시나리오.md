`주문 등록` 시 [[주문 전송]]이 수행되어야 한다. 만약 [[주문 전송]] 과정에서 예외가 발생하더라도 `주문 등록`은 완료되어야 한다. (이후 주문 재전송 혹은 주문 전송 api를 호출하여 재전송)

[[ApplicationEventPublisher]]를 사용하여 문제를 해결할 수 있다.

```java
// 주문 등록

@Service
@RequiredArgsConstructor
public class TcOrderServiceImpl implements TcOrderService {

	private final MessageProvider messageProvider;

	@Override  
	@Transactional  
	public int registerTcOrderListExcel(InputStream inputStream, String userId, Integer vendorId) throws Exception {  

		...
	
	    // 3. List<TcOrderExcelUpDTO> ->  List<TcOrder> 변환  
	    message = registerTcOrderList(tcOrderExcelUpDTOList, vendorId);  
	  
	    if (!StringUtils.isEmpty(message)) {  
	        throw new TcOrderRegisterExcelException(message);  
	    }  
	  
	    return tcOrderExcelUpDTOList.size();  
	}

	public String registerTcOrderList(List<TcOrderExcelUpDTO> tcOrderExcelUpDTOList, Integer vendorId) throws TomsException {  
  
	    StringBuilder builder = new StringBuilder();  
	    List<TcOrder> tcOrderList = new ArrayList<>();  
	  
	    ...
	  
	    List<TcOrder> autoSendingList = tcOrderList.stream()  
	            .filter((tcOrder -> tcOrder.getCourierOperation().getOperationPossible()))  
	            .collect(Collectors.toList());  
	    messageProvider.sendTcOrderList(autoSendingList);  
	  
	    return builder.toString();  
	}
}

@Service  
@RequiredArgsConstructor  
public class MessageProviderImpl implements MessageProvider, ApplicationEventPublisherAware {  
    private final ActiveMqProvider activeMqProvider;  
    private final KafkaProducer kafkaProducer;  
    private ApplicationEventPublisher applicationEventPublisher;

	/**  
	 * TC 주문 등록후 자동 전송 Event  
	*/
	@Override  
	public void sendTcOrderList(List<TcOrder> tcOrderList) {  
	    TcOrderSendEvent tcOrderSendEvent = new TcOrderSendEvent(tcOrderList);  
	    this.applicationEventPublisher.publishEvent(tcOrderSendEvent);  
	}

	// kafka 주문, 회수 각각 전송  
	@Override  
	public void sendOrderAndReturnToKafka(List<TcOrder> list) {  
	    ArrayList<TcOrder> orderList = new ArrayList<>(), returnList = new ArrayList<>();  
	    for (TcOrder tcOrder : list) {  
	        if (tcOrder.isReturnOrder()) {  
	            returnList.add(tcOrder);  
	        } else {  
	            orderList.add(tcOrder);  
	        }  
	    }  
	    this.sendTcOrderToKafka(orderList);  
	    this.sendReturnToKafka(returnList);  
	}

	@Override  
	public void sendTcOrderToKafka(List<TcOrder> orderList) {  
	    int size = orderList.size();
	      
	    if(size > 0) {  
	        long orderBatchNumber = transferSequenceServiceHelper.generateOrderBatchNumber();  
	  
		    for(int i=0;i<size;i++) {  
		        OrderInterface orderInterface = OrderInterface.toOrderInterface(orderList.get(i), size, orderBatchNumber, i+1);  
		        this.kafkaProducer.sendOrderMessage(orderInterface);  
		    }  
		}  
	}  
  
	@Override  
	public void sendReturnToKafka(List<TcOrder> returnList) {  
	    int size = returnList.size();  
	    if(size > 0) {  
	        long orderBatchNumber = transferSequenceServiceHelper.generateReturnBatchNumber();  
	  
	        for(int i=0;i<size;i++) {  
	            OrderInterface returnOrderInterface = OrderInterface.toOrderInterface(returnList.get(i), size, orderBatchNumber, i+1);  
	            this.kafkaProducer.sendReturnMessage(returnOrderInterface);  
	        }  
	    }  
	}
}
```

```java
// 주문 전송

@Service  
@RequiredArgsConstructor  
public class EventMessageListener {  
  
    @NonNull  
    private final TcOrderService tcOrderService;

	@Async  
	@TransactionalEventListener(classes = TcOrderSendEvent.class)  
	public void onSendTcOrder(TcOrderSendEvent tcOrderSendEvent) {  
	    List<TcOrder> tcOrderList = tcOrderSendEvent.getOrderList();  
	    tcOrderService.sendTcOrder(tcOrderList);  
	}
}

@Service
@RequiredArgsConstructor
public class TcOrderServiceImpl implements TcOrderService {

	@Override  
	@Transactional(isolation = Isolation.REPEATABLE_READ)  
	public int sendTcOrder(List<TcOrder> tcOrderList) {  
	    try {  
	        this.tcOrderServiceHelper.generateDeliveryInformation(tcOrderList);  
	    } catch (OptimisticLockingFailureException lockingFailureException) {  
	        throw new TomsException(TomsErrorCode.ORDER_SEND_DATALOCK, lockingFailureException);  
	    }  
	  
	    List<TcOrder> possibleOrderList = tcOrderList.stream()  
	            .filter(tcOrder -> tcOrder.getCourierOperation().getOperationPossible())  
	            .collect(toList());  
	  
	    // kafka 주문, 회수 각각 전송  
	    List<TcOrder> argoTmsOrderList = possibleOrderList.stream()  
	            .filter(order -> order.getCourierOperation().isKurlyOrder())  
	            .collect(toList());  
	    this.messageProvider.sendOrderAndReturnToKafka(argoTmsOrderList);  
	  
	    //택배 등록 Message Event 호출  
	    List<TcOrder> cjdtOrderList = new ArrayList<>();  
	    possibleOrderList.stream().forEach(tcOrder -> {  
	        CourierOperation courierOperation = tcOrder.getCourierOperation();  
	        if (courierOperation.isParcel()) {  
	            switch (courierOperation.getCourierCode()) {  
	                case CJDT:  
	                    cjdtOrderList.add(tcOrder);  
	                    break;  
	            }  
	        }  
	    });  
	    messageProvider.publishParcelOrderSendEvent(cjdtOrderList, CourierCode.CJDT);  
	  
	    OrderSendPagingDto pagingDto = new OrderSendPagingDto(possibleOrderList, MAX_ORDER_COUNT_PER_SEND);  
	    try {  
	        // mq 전송  
	        while (pagingDto.hasSendingOrder()) {  
	            List<TcOrder> publishOrderList = pagingDto.getCurrentPageList();  
	  
	            List<OrderInterfaceMaster> convertOrderList = publishOrderList.stream()  
	                    .map(tcOrder -> OrderInterfaceMaster.toOrderInterfaceMaster(tcOrder))  
	                    .collect(Collectors.toList());  
	            messageProvider.publishTcOrderList(convertOrderList, true);  
	  
	            pagingDto.goNextPage();  
	        }  
	    } catch (Exception e) {  
	        log.error("[MQ TC 전송 실패] : {}회차 \n{}", pagingDto.getCurrentPage() + 1, e.toString());  
	  
	        String displayName = "[TOMS WMS 주문전송 오류 발생]";   // 레거시 TMS 에서 현재 받고있으나, fade out 예정 & 현 TMS 전송 메시지 내용과 혼돈을 피하기 위해서 WMS라고 전송  
	        String messageContent = new StringBuilder()  
	                .append("<!channel>\n")  
	                .append(":alert::alert:주문 전송 과정에서 오류가 발생하였습니다.:alert::alert: ")  
	                .append(LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))).append("\n")  
	                .toString();  
	        noticeProxy.sendErrorNotice(displayName, messageContent, e);  
	    }  
	  
	    return possibleOrderList.size();  
	}
}
```

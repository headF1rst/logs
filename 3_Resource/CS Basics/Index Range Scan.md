#papercut 

검색할 인덱스의 범위가 결정된 쿼리에 사용하는 인덱스 활용 방식.

```sql
select * from employees
where first_name between 'Ebbe' AND 'Gad';
```

![[스크린샷 2024-01-05 오전 1.21.23.png]]
![[스크린샷 2024-01-05 오전 1.21.49.png]]

B-Tree 인덱스에서 루트와 브랜치 노드를 이용해 리프 노드에서 검색 시작 인덱스를 찾은 다음 해당 지점부터 인덱스를 순차적으로 읽어나가며 정렬 상태의 인덱스로 부터 레코드를 가져온다.

이때 인덱스와 매핑된 **레코드 주소값으로 데이터 파일에 접근**하여 레코드를 가져오는데, **레코드 하나 당** [[랜덤 I/O]]가 **한 건 발생**한다.

인덱스를 통해 읽어야할 레코드가 20 ~ 25%를 넘기면 인덱스를 통한 읽기보다 테이블의 데이터를 직접 읽는게 효율적이다.
### Index Range Scan 단계

1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다. (Index **Seek**)
2. 1번에서 찾은 위치부터 필요한 만큼 인덱스를 순서대로 읽는다. (Index **Scan**)
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 통해 레코드가 저장된 페이지를 가져오고, 레코드를 읽어온다.

쿼리가 요구하는 데이터에 따라 [[커버링 인덱스]]로 처리가 가능하다면 Index Range Scan 과정에서 3번 과정이 생략된다.

[[커버링 인덱스]]로 처리되는 쿼리는 디스크의 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 상당히 줄어들고 성능이 빨라진다.
#papercut  #Database

`Unique Index`: 인덱스에 중복된 값이 존재하면 안된다는 **제약조건**
(null도 유니크 인덱스에 저장 가능한데, null은 특정 값이 아니기 때문에 중복될 수 있다.)

PK도 고유값이라는 점에서는 유니크 인덱스와 같지만 InnoDB 스토리지의 PK는 클러스터링 키 역할도 할 수 있다는 차이가 있다.

유니크 인덱스는 일반적인 인덱스와 같은 역할을 한다.
때문에 같은 테이블의 동일 컬럼에 유니크 인덱스를 걸고 추가로 세컨더리 인덱스를 걸 필요 없다.
또한 동일 컬럼에 대해 PK와 유니크 인덱스를 생성할 필요도 없다.

유니크 인덱스와 세컨더리 인덱스의 성능은 읽기의 경우 동일하지만 쓰기의 경우 유니크 인덱스가 더 **느리다**.

읽기의 경우 유니크 인덱스는 한 건만 읽으면 되고, 세컨더리 인덱스 추가 작업 한 건이 더 필요 하다. 
하지만 디스크에서 레코드를 추가로 읽는게 아니라 **CPU에서 컬럼값을 비교하는 작업이 필요**한 것이기 때문에 인덱스 특성상의 성능 차이는 없다.

쓰기의 경우 인덱스 컬럼에 변경이 일어나거나 새로운 데이터가 삽입 됐을때 일어나는데, 유니크 인덱스의 경우 **중복값을 체크**해야 하기 때문에 버퍼링 자체가 불가하여 InnoDB의 [[Change Buffer]]를 사용하지 못한다.
또한 **중복값 체크에 읽기 잠금**을, **인덱스 쓰기 작업에 쓰기 잠금**을 걸게 되는데, 이 과정에서 **데드락**이 빈번하게 발생한다.

유일성이 꼭 보장되어야 하는 컬럼에만 유니크 인덱스를 생성하고 그 외는 세컨더리 인덱스를 고려하자.